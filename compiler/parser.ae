use "./compiler/ast.ae"
use "./compiler/utils.ae"

struct Parser {
    tokens: &Vector
    curr: i32
}

def Parser::make(tokens: &Vector): &Parser {
    let parser = calloc(1, sizeof(Parser)) as &Parser
    parser.tokens = tokens
    parser.curr = 0
    return parser
}

def Parser::error(&this, msg: string) {
    error_span(.token().span, msg)
}

def Parser::unhandled_type(&this, func: string) {
    .error(`Unexpected token in {func}: {.token().type.str()}`)
}

def Parser::token(&this): &Token {
    return .tokens.at(.curr) as &Token
}

def Parser::token_is(&this, type: TokenType): bool {
    return .token().type == type
}

def Parser::consume_if(&this, type: TokenType): bool {
    if .token_is(type) {
        .curr += 1
        return true
    }
    return false
}

def Parser::consume_newline_or(&this, type: TokenType) {
    if .token_is(type) {
        .curr += 1
    } else if not .token().seen_newline {
        .error(`Expected {type.str()} or newline`)
    }
}

def Parser::consume(&this, type: TokenType): &Token {
    if not .consume_if(type) {
        .error(`Expected TokenType::{type.str()}`)
    }
    return .tokens.at(.curr - 1) as &Token
}


def Parser::parse_type(&this): &Type {
    .unhandled_type("parse_type")
    exit(1)
    return 0 as &Type
}

def Parser::parse_factor(&this): &AST {
    let node = 0 as &AST
    if .token_is(TokenType::IntLiteral) {
        node = AST::new(ASTType::IntLiteral, .token().span)
        let tok = .consume(TokenType::IntLiteral)
        node.u.num_literal = tok.text

    } else if .token_is(TokenType::FloatLiteral) {
        node = AST::new(ASTType::FloatLiteral, .token().span)
        let tok = .consume(TokenType::FloatLiteral)
        node.u.num_literal = tok.text

    } else if .token_is(TokenType::StringLiteral) {
        node = AST::new(ASTType::StringLiteral, .token().span)
        let tok = .consume(TokenType::StringLiteral)
        node.u.string_literal = tok.text

    } else if .token_is(TokenType::Minus) {
        let op = .consume(TokenType::Minus)
        let expr = .parse_factor()
        node = AST::new_unop(ASTType::UnaryMinus, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Not) {
        let op = .consume(TokenType::Not)
        let expr = .parse_factor()
        node = AST::new_unop(ASTType::Not, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Ampersand) {
        let op = .consume(TokenType::Ampersand)
        let expr = .parse_factor()
        node = AST::new_unop(ASTType::Address, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Star) {
        let op = .consume(TokenType::Star)
        let expr = .parse_factor()
        node = AST::new_unop(ASTType::Dereference, op.span.join(expr.span), expr)

    } else if .token_is(TokenType::Identifier) {
        let op = .consume(TokenType::Identifier)
        node = AST::new(ASTType::Identifier, op.span)
        node.u.ident.name = op.text

    } else if .token_is(TokenType::OpenParen) {
        let open = .consume(TokenType::Identifier)
        node = .parse_expression()
        let close = .consume(TokenType::CloseParen)
        node.span = open.span.join(close.span)

    } else if .token_is(TokenType::SizeOf) {
        let start = .consume(TokenType::SizeOf)
        .consume(TokenType::OpenParen)
        let type = .parse_type()
        let close = .consume(TokenType::CloseParen)
        node = AST::new(ASTType::SizeOf, start.span.join(close.span))
        node.u.size_of_type = type

    } else {
        .unhandled_type("parse_expression")
    }
    return node
}

def Parser::parse_expression(&this): &AST {
    return .parse_factor()
}

def Parser::parse_statement(&this): &AST {
    let node = 0 as &AST

    if .token_is(TokenType::Return) {
        node = AST::new(ASTType::Return, .token().span)
        .consume(TokenType::Return)
        node.u.unary = .parse_expression()
    } else {
        .unhandled_type("parse_statement")
    }

    return node
}

def Parser::parse_block(&this): &AST {
    let node = AST::new(ASTType::Block, .token().span)
    .consume(TokenType::OpenCurly)

    let statements = Vector::new()
    while not .token_is(TokenType::CloseCurly) {
        let statement = .parse_statement()
        statements.push(statement as untyped_ptr)
    }
    node.u.block.statements = statements

    .consume(TokenType::CloseCurly)
    return node;
}

def Parser::parse_function(&this): &Function {
    .consume(TokenType::Def)

    let struct_name = 0 as string
    let is_method = false
    let is_static = false
    let name = .consume(TokenType::Identifier)
    if .consume_if(TokenType::ColonColon) {
        is_method = true
        struct_name = name.text
        name = .consume(TokenType::Identifier)
    }

    let func = Function::new(name.span)
    func.name = name.text
    func.is_method = is_method
    func.method_struct_name = struct_name

    .consume(TokenType::OpenParen)
    while not .token_is(TokenType::CloseParen) {
        let var_name = .consume(TokenType::Identifier)
        .consume(TokenType::Colon)
        let var_type = .parse_type()
        let var = Variable::new(var_name.text, var_type, var_name.span)
        func.params.push(var as untyped_ptr)
    }
    .consume(TokenType::CloseParen)

    if .consume_if(TokenType::Colon) {
        func.return_type = .parse_type()
    } else {
        func.return_type = Type::new(BaseType::Void, name.span)
    }

    func.is_extern = false
    func.body = .parse_block()
    return func
}

def Parser::parse_program(&this): &Program {
    let program = Program::new()
    while not .token_is(TokenType::EOF) {
        if .token_is(TokenType::Def) {
            let func = .parse_function()
            program.functions.push(func as untyped_ptr)
        } else {
            .unhandled_type("parse_program")
        }
    }
    return program
}