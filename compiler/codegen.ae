use "@/ast.ae"

struct CodeGenerator {
    out: &File
    scopes: &Vector  // Vector<Vector<AST>>
}

def CodeGenerator::make(filename: string): CodeGenerator {
    let gen: CodeGenerator
    gen.out = File::open(filename, "w")
    gen.scopes = Vector::new()
    return gen
}

def CodeGenerator::indent(&this, num: i32) {
    for let i = 0; i < num; i += 1 {
        .out.puts("  ")
    }
}

def CodeGenerator::push_scope(&this) {
    .scopes.push(Vector::new() as untyped_ptr)
}

def CodeGenerator::scope(&this): &Vector {
    return .scopes.back() as &Vector
}

def CodeGenerator::pop_scope(&this) {
    let scope = .scopes.pop() as &Vector
    scope.free()
}

def CodeGenerator::gen_control_body(&this, node: &AST, indent: i32) {
  if node.type == ASTType::Block {
    .gen_block(node, indent);
    .out.puts(" ")
  } else {
    if node.type != ASTType::If {
        .out.puts("\n")
    }
    .gen_statement(node, indent);
    .indent(indent);
  }
}

def CodeGenerator::gen_enum_value(&this, enum_name: string, value_name: string) {
  .out.puts(`{enum_name}__{value_name}`);
}

def CodeGenerator::gen_enum(&this, struc: &Structure) {
    if not struc.is_extern {
        .out.puts(`enum {struc.name}`);
        .out.puts(" {\n")
        for let i = 0; i < struc.fields.size; i += 1 {
            let field = struc.fields.at(i) as &Variable
            .indent(1)
            .gen_enum_value(struc.name, field.name);
            .out.puts(",\n");
        }
        .out.puts("};\n\n");
    }
}

def CodeGenerator::gen_struct(&this, struc: &Structure) {
    if not struc.is_extern {
        let name = struc.type.name;
        if (struc.is_union) {
            .out.puts("union ")
        } else {
            .out.puts("struct ")
        }
        .out.puts(name)
        .out.puts(" {\n")
        for let i = 0; i < struc.fields.size; i += 1 {
            let field = struc.fields.at(i) as &Variable
            .indent(1)
            .gen_type_and_name(field.type, field.name);
            .out.puts(";\n")
        }
        .out.puts("};\n\n")
    }
}

def CodeGenerator::get_op(type: ASTType): string {
    match type {
        Address => return "&"
        And => return " && "
        Assignment => return " = "
        BitwiseAnd => return " & "
        BitwiseOr => return " | "
        BitwiseXor => return " ^ "
        Dereference => return "*"
        Divide => return " / "
        DivideEquals => return " /= "
        Equals => return " == "
        GreaterThan => return " > "
        GreaterThanEquals => return " >= "
        LessThan => return " < "
        LessThanEquals => return " <= "
        Minus => return " - "
        MinusEquals => return " -= "
        Modulus => return " % "
        Multiply => return " * "
        MultiplyEquals => return " *= "
        Not => return "!"
        NotEquals => return " != "
        Or => return " || "
        Plus => return " + "
        PlusEquals => return " += "
        UnaryMinus => return "-"
        else => {
            println("Unknown op type in get_op: %s", type.str())
            exit(1)
        }
    }
}

def CodeGenerator::gen_type(&this, type: &Type) {
    match type.base {
        BaseType::Void => this.out.puts("void")
        BaseType::Char => this.out.puts("char")
        BaseType::I32 => this.out.puts("int")
        BaseType::F32 => this.out.puts("float")
        BaseType::Bool => this.out.puts("bool")
        BaseType::U8 => this.out.puts("unsigned char")
        BaseType::Pointer => {
            .gen_type(type.ptr)
            .out.puts("*")
        }
        BaseType::Structure => {
            if type.struct_def.is_extern {
                .out.puts(type.struct_def.extern_name)
            } else {
                .out.puts(type.struct_def.name)
            }
        }
        else => {
            println("Unknown type in gen_type: %s", type.str())
            exit(1)
        }
    }
}

def CodeGenerator::gen_expression(&this, node: &AST) {
    match node.type {
        IntLiteral => .out.puts(node.u.num_literal)
        FloatLiteral => .out.puts(node.u.num_literal)
        StringLiteral => .out.puts(`\"{node.u.string_literal}\"`)
        CharLiteral => .out.puts(`'{node.u.char_literal}'`)
        BoolLiteral => {
            if node.u.bool_literal {
                .out.puts("true")
            } else {
                .out.puts("false")
            }
        }
        Identifier => {
            let ident = node.u.ident
            if ident.is_function {
                .gen_function_name(ident.func)
            } else if ident.var.is_extern {
                .out.puts(ident.var.extern_name)
            } else {
                .out.puts(ident.var.name)
            }
        }
        Call => {
            let newline_after_first = false;
            if node.callee_is("print") {
                .out.puts("printf")
            } else if node.callee_is("println") {
                .out.puts("printf")
                newline_after_first = true;
            } else if node.u.call.func == 0 as &Function {
                .gen_expression(node.u.call.callee);
            } else {
                .gen_function_name(node.u.call.func);
            }
            .out.puts("(")
            let args = node.u.call.args
            for let i = 0; i < args.size; i += 1 {
                if i > 0 { .out.puts(", "); }
                .gen_expression(args.at(i) as &AST)
                if i == 0 and newline_after_first { .out.puts(" \"\\n\""); }
            }
            .out.puts(")")
        }
        And |
        BitwiseAnd |
        BitwiseOr |
        BitwiseXor |
        Divide |
        GreaterThan |
        GreaterThanEquals |
        LessThan |
        LessThanEquals |
        Minus |
        Modulus |
        Multiply |
        NotEquals |
        Or |
        Plus => {
            .out.puts("(")
            .gen_expression(node.u.binary.lhs)
            .out.puts(CodeGenerator::get_op(node.type))
            .gen_expression(node.u.binary.rhs)
            .out.puts(")")
        }
        Address | Dereference | Not | UnaryMinus => {
            .out.puts("(")
            .out.puts(CodeGenerator::get_op(node.type))
            .gen_expression(node.u.unary)
            .out.puts(")")
        }
        Index => {
            .gen_expression(node.u.binary.lhs)
            .out.puts("[")
            .gen_expression(node.u.binary.rhs)
            .out.puts("]")
        }
        Member => {
            .gen_expression(node.u.member.lhs)
            if node.u.member.is_pointer {
                .out.puts("->")
            } else {
                .out.puts(".")
            }
            .out.puts(node.u.member.name)
        }
        EnumValue => {
            let enum_value = node.u.enum_val
            .gen_enum_value(enum_value.struct_def.name, enum_value.name)
        }
        Cast => {
            .out.puts("((")
            .gen_type(node.u.cast.to)
            .out.puts(")")
            .gen_expression(node.u.cast.lhs)
            .out.puts(")")
        }
        FormatStringLiteral => {
            .out.puts("__format_string(\"")
            .out.puts(node.u.fmt_str.str)
            .out.puts("\"")
            let exprs = node.u.fmt_str.exprs
            for let i = 0; i < exprs.size; i += 1 {
                let expr = exprs.at(i) as &AST
                .out.puts(", ")
                .gen_expression(expr)
            }
            .out.puts(")")
        }
        Defer => .scope().push(node.u.unary as untyped_ptr)
        SizeOf => {
            .out.puts("sizeof(")
            .gen_type(node.u.size_of_type)
            .out.puts(")")
        }
        Equals |
        Assignment |
        PlusEquals |
        MinusEquals |
        DivideEquals |
        MultiplyEquals => {
            .gen_expression(node.u.binary.lhs)
            .out.puts(CodeGenerator::get_op(node.type))
            .gen_expression(node.u.binary.rhs)

        }
        else => {
            println("unknown type in gen_expression: %s", node.type.str())
            exit(1)
        }
    }
}

def CodeGenerator::gen_var_decl(&this, node: &AST) {
    let var = node.u.var_decl.var
    if var.is_extern return
    .gen_type_and_name(var.type, var.name)
    if node.u.var_decl.init != 0 as &AST {
        .out.puts(" = ")
        .gen_expression(node.u.var_decl.init)
    }
}

def CodeGenerator::gen_match_string(&this, node: &AST, indent: i32) {
    let stmt = node.u.match_stmt
    .indent(indent)
    .out.puts("{\n")
    .indent(indent + 1)
    .out.puts("char *__match_str = ")
    .gen_expression(stmt.expr)
    .out.puts(";\n")

    let cases = stmt.cases
    .indent(indent + 1)
    .out.puts("if (")
    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        .out.puts("streq(__match_str, ")
        .gen_expression(_case.cond)
        .out.puts(")")

        if _case.body != 0 as &AST {
            .out.puts(")")
            .gen_match_case_body(_case.body, indent)
            .out.puts(" else ")
            if i != cases.size - 1 {
                .out.puts("if (")
            }
        } else {
            .out.puts(" || ")
        }
    }
    if stmt.defolt != 0 as &AST {
        .gen_match_case_body(stmt.defolt, indent)
    }
    .out.puts("\n")
    .indent(indent)
    .out.puts("}\n")
}

def CodeGenerator::gen_match_case_body(&this, node: &AST, indent: i32) {
    if node.type == ASTType::Block {
        .out.puts(" ")
        .gen_block(node, indent + 1)
    } else {
        .out.puts(" {\n")
        .gen_statement(node, indent + 2)
        .indent(indent + 1)
        .out.puts("}")
    }
}

def CodeGenerator::gen_match(&this, node: &AST, indent: i32) {
    let stmt = node.u.match_stmt
    if stmt.expr.etype.is_string() {
        .gen_match_string(node, indent)
        return
    }

    .indent(indent)
    .out.puts("switch (")
    .gen_expression(stmt.expr)
    .out.puts(") {\n")

    let cases = stmt.cases
    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        .indent(indent + 1)
        .out.puts("case ")
        .gen_expression(_case.cond)
        .out.puts(":")
        if _case.body != 0 as &AST {
            .gen_match_case_body(_case.body, indent)
            .out.puts(" break;\n")

        } else {
            .out.puts("\n")
        }
    }
    if stmt.defolt != 0 as &AST {
        .indent(indent + 1)
        .out.puts("default:")
        .gen_match_case_body(stmt.defolt, indent)
        .out.puts(" break;\n")
    }
    .indent(indent)
    .out.puts("}\n")
}

def CodeGenerator::gen_statement(&this, node: &AST, indent: i32) {
    if node.type == ASTType::Return {
        .indent(indent)
        .out.puts("return")
        if node.u.unary != 0 as &AST {
            .out.puts(" ")
            .gen_expression(node.u.unary)
        }
        .out.puts(";\n")

    } else if node.type == ASTType::Match {
        .gen_match(node, indent)

    } else if node.type == ASTType::Break {
        .indent(indent)
        .out.puts("break;\n")

    } else if node.type == ASTType::Continue {
        .indent(indent)
        .out.puts("continue;\n")

    } else if node.type == ASTType::VarDeclaration {
        .indent(indent)
        .gen_var_decl(node)
        .out.puts(";\n")

    } else if node.type == ASTType::If {
        .indent(indent)
        .out.puts("if (")
        .gen_expression(node.u.if_stmt.cond)
        .out.puts(")")
        .gen_control_body(node.u.if_stmt.then, indent)
        if node.u.if_stmt.els != 0 as &AST {
            .out.puts(" else ")
            .gen_control_body(node.u.if_stmt.els, indent)
        }
        .out.puts("\n")

    } else if node.type == ASTType::While {
        .indent(indent)
        .out.puts("while (")
        .gen_expression(node.u.loop.cond)
        .out.puts(") ")
        .gen_control_body(node.u.loop.body, indent)
        .out.puts("\n")

    } else if node.type == ASTType::For {
        .indent(indent)
        .out.puts("for (")
        if node.u.loop.init != 0 as &AST {
            if node.u.loop.init.type == ASTType::VarDeclaration {
                .gen_var_decl(node.u.loop.init)
            } else {
                .gen_expression(node.u.loop.init)
            }
        }
        .out.puts("; ")
        if node.u.loop.cond != 0 as &AST {
            .gen_expression(node.u.loop.cond)
        }
        .out.puts("; ")
        if node.u.loop.incr != 0 as &AST {
            .gen_expression(node.u.loop.incr)
        }
        .out.puts(") ")
        .gen_control_body(node.u.loop.body, indent)
        .out.puts("\n")


    } else if node.type == ASTType::Block {
        .indent(indent)
        .gen_block(node, indent)
        .out.puts("\n")

    } else {
        .indent(indent)
        .gen_expression(node)
        .out.puts(";\n")
    }
}

def CodeGenerator::gen_block(&this, node: &AST, indent: i32) {
    .push_scope()
    .out.puts("{\n")

    let statements = node.u.block.statements;
    for let i = 0; i < statements.size; i += 1 {
        let statement = statements.at(i) as &AST;
        .gen_statement(statement, indent + 1)
    }

    let defers = .scope()
    if defers.size > 0 {
        .out.puts("\n")
        .indent(indent)
        .out.puts("/* defers */\n")
        for let i = defers.size - 1; i >= 0; i -= 1 {
            let node = defers.at(i) as &AST
            .gen_statement(node, indent + 1)
        }
    }

    .indent(indent)
    .out.puts("}")
    .pop_scope()
}

def CodeGenerator::gen_struct_decls(&this, program: &Program) {
    .out.puts("/* struct declarations */\n")
    for let i = 0; i < program.structures.size; i += 1 {
        let struc = program.structures.at(i) as &Structure;
        if struc.is_extern continue

        let name = struc.name;
        if (struc.is_enum) {
            .out.puts("typedef enum ")
        } else if (struc.is_union) {
            .out.puts("typedef union ")
        } else {
            .out.puts("typedef struct ")
        }
        .out.puts(`{name} {name};\n`)
    }
    .out.puts("\n")
}

def CodeGenerator::gen_type_and_name(&this, type: &Type, name: string) {
    if type.base == BaseType::Function {
        .gen_type(type.return_type)
        .out.puts(`(*{name})(`)
        for let i = 0; i < type.params.size; i += 1 {
            if i > 0 { .out.puts(", "); }
            .gen_type(type.params.at(i) as &Type)
        }
        .out.puts(")")
    } else {
        .gen_type(type)
        .out.puts(` {name}`)
    }
}

def CodeGenerator::gen_function_name(&this, func: &Function) {
    if func.is_extern {
        .out.puts(func.extern_name)
    } else if func.is_method {
        .out.puts(`{func.method_struct_name}__{func.name}`)
    } else {
        .out.puts(func.name)
    }
}

def CodeGenerator::gen_function_decl(&this, func: &Function) {
    if func.exits
        .out.puts("__attribute__((noreturn)) ")

    .gen_type(func.return_type)
    .out.puts(" ")
    .gen_function_name(func)
    .out.puts("(")

    for let i = 0; i < func.params.size; i += 1 {
        let param = func.params.at(i) as &Variable
        if i > 0 { .out.puts(", "); }
        .gen_type_and_name(param.type, param.name)
    }
    .out.puts(")")
}

def CodeGenerator::gen_function_decls(&this, program: &Program) {
    .out.puts("/* function declarations */\n")
    for let i = 0; i < program.functions.size; i += 1 {
        let func = program.functions.at(i) as &Function
        if not func.is_extern {
            .gen_function_decl(func)
            .out.puts(";\n")
        }
    }
    .out.puts("\n")
}

def CodeGenerator::gen_function(&this, func: &Function) {
    if func.is_extern return
    .gen_function_decl(func)
    .out.puts(" ")
    .gen_block(func.body, 0)
    .out.puts("\n\n")
}

def CodeGenerator::gen_global_vars(&this, program: &Program) {
    .out.puts("/* global variables */\n")
    for let i = 0; i < program.global_vars.size; i += 1 {
        let node = program.global_vars.at(i) as &AST
        if not node.u.var_decl.var.is_extern {
            .gen_statement(node, 0)
        }
    }
    .out.puts("\n")
}

def CodeGenerator::gen_embed_headers(&this, program: &Program) {
    if not program.c_embed_headers.empty() {
        for let i = 0; i < program.c_embed_headers.size; i += 1 {
            let filename = program.c_embed_headers.at(i) as string
            .out.puts(`/***************** embed '{filename}' *****************/\n`)

            let file = File::open(filename, "r")
            defer file.close()

            let contents = file.slurp()
            defer free(contents as untyped_ptr)

            .out.puts(contents)
            .out.puts("\n\n")
        }
    }
}

def CodeGenerator::gen_program(&this, program: &Program) {
    for let i = 0; i < program.c_includes.size; i += 1 {
        let include = program.c_includes.at(i) as string
        .out.puts(`#include \"{include}\"\n`)
    }
    .out.puts("\n")

    .gen_embed_headers(program)

    .gen_struct_decls(program)
    for let i = 0; i < program.structures.size; i += 1 {
        let struc = program.structures.at(i) as &Structure
        if struc.is_enum {
            .gen_enum(struc)
        } else {
            .gen_struct(struc)
        }
    }

    .gen_function_decls(program)
    .gen_global_vars(program)
    for let i = 0; i < program.functions.size; i += 1 {
        let func = program.functions.at(i) as &Function
        .gen_function(func)
    }
    .out.close()
}
