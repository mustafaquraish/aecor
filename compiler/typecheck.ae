use "@/ast.ae"
use "lib/map.ae"

struct TypeChecker {
    scopes: &Vector   // &Vector<&Map<string, &Variable>>
    functions: &Map   // &Map<string, &Function>
    structures: &Map  // &Map<string, &Structure>
    methods: &Map     // &Map<string, &Map<string, &Function>>
    cur_func: &Function
    in_loop: bool
    can_yield: bool
}

def TypeChecker::new(): &TypeChecker {
    let checker = calloc(1, sizeof(TypeChecker)) as &TypeChecker
    checker.scopes = Vector::new()
    checker.functions = Map::new()
    checker.structures = Map::new()
    checker.methods = Map::new()

    // FIXME: This is a hack to attach methods to strings:
    checker.methods.insert("string", Map::new())

    return checker
}

def TypeChecker::push_scope(&this) {
    let scope = Map::new()
    .scopes.push(scope)
}

def TypeChecker::scope(&this): &Map {
    return .scopes.back() as &Map
}

def TypeChecker::pop_scope(&this) {
    let scope = .scopes.pop() as &Map
    scope.free()
}

def TypeChecker::push_var(&this, var: &Variable) {
    let scope = .scope()
    let existing = scope.get(var.name) as &Variable
    if existing? {
        error_span_note_span(
            var.span, "Variable is already defined in scope",
            existing.span, "Previous definition here"
        )
    }
    .scope().insert(var.name, var)
}

def TypeChecker::find_var(&this, name: string): &Variable {
    for let i = .scopes.size - 1; i >= 0; i -= 1 {
        let scope = .scopes.at(i) as &Map
        let var = scope.get(name) as &Variable
        if var? return var
    }
    return null
}

def TypeChecker::get_struct_member(&this, lhs: string, rhs: string): &Variable {
    let struc = .structures.get(lhs) as &Structure
    return if struc? then struc.find_field(rhs) else null
}

def TypeChecker::type_is_valid(&this, type: &Type): bool {
    match type.base {
        BaseType::Pointer => return .type_is_valid(type.ptr)
        BaseType::Function => {
            for let i = 0; i < type.params.size; i += 1 {
                if not .type_is_valid(type.params.at(i) as &Type) {
                    return false
                }
            }
            return .type_is_valid(type.return_type)
        }
        BaseType::Structure => {
            let struc = .structures.get(type.name) as &Structure
            if struc? {
                type.struct_def = struc
                return true
            }
            return false
        }
        else => return true
    }
}

def TypeChecker::check_method_call(&this, method_type: &Type, node: &AST) {
    let callee = node.u.call.callee
    if callee.type != ASTType::Member and callee.type != ASTType::ScopeLookup {
        error_span(callee.span,
                "Method call is not to a member, internal compiler error")
    }

    let s_methods = .methods.get(method_type.name) as &Map
    let method = s_methods.get(callee.u.member.name) as &Function
    node.u.call.func = method

    // Due to the way we handle typechecking, we might run this function twice
    // on the same node. This is fine, but we need to make sure we don't double
    // add the method argument twice implicitly.
    if node.u.call.added_method_arg return
    node.u.call.added_method_arg = true;

    if callee.type != ASTType::Member return
    if method.params.size == 0 {
        // This should ideally never happen.
        error_span(callee.span, "Instance method should have `this` argument, internal error");
    }
    let method_param = (method.params.at(0) as &Variable).type

    let member = callee.u.member
    let first_arg = member.lhs
    if member.is_pointer and method_param.name? {
        first_arg = AST::new_unop(ASTType::Dereference, first_arg.span, first_arg)
    } else if not member.is_pointer and not method_param.name? {
        first_arg = AST::new_unop(ASTType::Address, first_arg.span, first_arg)
    }
    node.u.call.args.push_front(first_arg)
}

def TypeChecker::check_call(&this, node: &AST): &Type {
    // This is a hack to avoid typechecking of `print` and `println`
    let callee = node.u.call.callee;
    if callee.type == ASTType::Identifier {
        callee.u.ident.is_function = false;
        let name = callee.u.ident.name;
        if name.eq("print") or name.eq("println") {
            for let i = 0; i < node.u.call.args.size; i += 1 {
                let arg = node.u.call.args.at(i) as &AST
                .check_expression(arg)
            }
            return Type::new(BaseType::Void, node.span)
        }
    }

    let func_type = .check_expression(callee);
    let func_def = func_type.func_def;
    node.u.call.func = func_def;

    if func_def? and func_def.exits {
        node.returns = true
    }

    if func_type.base != BaseType::Function and func_type.base != BaseType::Method {
        error_span_note(
            callee.span, "Cannot call a non-function type",
            `Type for expression is '{func_type.str()}'`
        )
    }

    if func_type.base == BaseType::Method {
        .check_method_call(func_type, node)
    }

    let params = func_type.params
    if params.size != node.u.call.args.size {
        error_span_note_span(
            node.span, "Number of arguments does not match function signature",
            func_type.span, `This function expects {params.size} arguments, got {node.u.call.args.size}`
        )
    }
    for let i = 0; i < params.size; i += 1 {
        let param = params.at(i) as &Type
        let arg = node.u.call.args.at(i) as &AST
        let arg_type = .check_expression(arg)
        if not param.eq(arg_type) {
            error_span_note_span(
                arg.span, "Argument type does not match function parameter type",
                param.span, `Expected '{param.str()}', got '{arg_type.str()}'`
            )
        }
    }

    return func_type.return_type;
}

def TypeChecker::check_format_string(&this, node: &AST): &Type {
    // FIXME: Refactor this with string builder, this is inefficient
    let parts = node.u.fmt_str.parts;
    let exprs = node.u.fmt_str.exprs;

    if parts.size != exprs.size + 1 {
        error_span(node.span, "Number of format string parts does not match number of expressions")
    }

    let size = 0
    for let i = 0; i < parts.size; i += 1 {
        size += (parts.at(i) as string).len() + 3
    }

    let buf = calloc(size + 1, 1) as string
    for let i = 0; i < exprs.size; i += 1 {
        let part = parts.at(i) as string
        let expr = exprs.at(i) as &AST

        buf.concat(part)
        let expr_type = .check_expression(expr)
        match expr_type.base {
            BaseType::I32 | BaseType::U8 => buf.concat("%d")
            BaseType::Bool => buf.concat("%s")
            BaseType::F32 => buf.concat("%f")
            BaseType::Char => buf.concat("%c")
            BaseType::Pointer => {
                if expr_type.ptr.base == BaseType::Char
                    buf.concat("%s")
                else
                    buf.concat("%p")
            }
            else => error_span(expr.span, "Invalid type for format string")
        }
    }
    buf.concat(parts.back() as string)
    node.u.fmt_str.str = buf
    return Type::ptr_to(BaseType::Char, node.span)
}

def TypeChecker::check_pointer_arith(&this, node: &AST, lhs: &Type, rhs: &Type): &Type {
    if node.type == ASTType::Plus or node.type == ASTType::Minus {
        if lhs.base == BaseType::Pointer and rhs.base == BaseType::I32 {
            return lhs
        }
        if lhs.base == BaseType::I32 and rhs.base == BaseType::Pointer {
            return rhs
        }
        if lhs.eq(rhs) and lhs.base == BaseType::Pointer {
            if node.type == ASTType::Minus {
                return Type::new(BaseType::I32, node.span)
            }
        }
    }
    error_span(node.span, "Invalid pointer arithmetic")
    return null as &Type
}

def TypeChecker::check_expression(&this, node: &AST): &Type {
    let etype = null as &Type
    match node.type {
        Call            => etype = .check_call(node)
        IntLiteral      => etype = Type::new(BaseType::I32, node.span)
        FloatLiteral    => etype = Type::new(BaseType::F32, node.span)
        BoolLiteral     => etype = Type::new(BaseType::Bool, node.span)
        StringLiteral   => etype = Type::ptr_to(BaseType::Char, node.span)
        CharLiteral     => etype = Type::new(BaseType::Char, node.span)
        Null            => etype = Type::ptr_to(BaseType::Void, node.span)
        FormatStringLiteral => etype = .check_format_string(node)
        SizeOf => {
            if not .type_is_valid(node.u.size_of_type) {
                error_span(node.u.size_of_type.span, "Invalid type")
            }
            etype = Type::new(BaseType::I32, node.span)
        }
        Identifier => {
            let ident = &node.u.ident;
            let var = .find_var(ident.name)
            let func = .functions.get(ident.name) as &Function

            if ident.is_function {
                etype = ident.func.type
            } else if var? {
                ident.is_function = false
                ident.var = var
                etype = var.type
            } else if func? {
                ident.is_function = true
                ident.func = func
                etype = func.type
            } else {
                error_span(node.span, "Unknown Identifier")
            }
        }
        Plus | Minus | Multiply | Divide => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if lhs.base == BaseType::Pointer or rhs.base == BaseType::Pointer {
                etype = .check_pointer_arith(node, lhs, rhs)
            } else if not lhs.is_numeric() or not rhs.is_numeric() {
                error_span_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            } else if not lhs.eq(rhs) {
                error_span_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            } else {
                etype = lhs
            }
        }
        LessThan | LessThanEquals | GreaterThan | GreaterThanEquals => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if not lhs.is_numeric() or not rhs.is_numeric() {
                error_span_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            if not lhs.eq(rhs) {
                error_span_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            etype = Type::new(BaseType::Bool, node.span)
        }
        Equals | NotEquals => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if not lhs.eq(rhs) {
                error_span_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            if lhs.base == BaseType::Structure {
                let struc = .structures.get(lhs.name) as &Structure
                if not struc.is_enum {
                    error_span(node.span, "Cannot compare structs directly")
                }
            }
            etype = Type::new(BaseType::Bool, node.span)
        }
        And | Or => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if not lhs.eq(rhs) or lhs.base != BaseType::Bool {
                error_span_note(
                    node.span, "Operands must be boolean",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            etype = Type::new(BaseType::Bool, node.span)
        }
        Not => {
            let rhs = .check_expression(node.u.unary)
            if rhs.base != BaseType::Bool {
                error_span_note(
                    node.u.unary.span, "Expression must be boolean",
                    `Got type '{rhs.str()}'`
                )
            }
            etype = Type::new(BaseType::Bool, node.span)
        }
        Modulus | BitwiseOr | BitwiseAnd | BitwiseXor => {
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if lhs.base != BaseType::I32 or rhs.base != BaseType::I32 {
                error_span_note(
                    node.span, "Operator requires integer types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            etype = lhs
        }
        UnaryMinus => {
            etype = .check_expression(node.u.unary)
            if not etype.is_numeric() {
                error_span_note(
                    node.u.unary.span, "Expression must be a number",
                    `Got type '{etype.str()}'`
                )
            }
        }
        Address => {
            etype = .check_expression(node.u.unary)
            etype = Type::new_link(BaseType::Pointer, etype, node.span)
        }
        Dereference => {
            let expr_type = .check_expression(node.u.unary)
            if expr_type.base != BaseType::Pointer {
                error_span_note(
                    node.u.unary.span, "Expression must be a pointer-type",
                    `Got type '{expr_type.str()}'`
                )
            }
            etype = expr_type.ptr
        }
        Index => {
            let expr_type = .check_expression(node.u.binary.lhs)
            if expr_type.base != BaseType::Pointer {
                error_span_note(
                    node.u.binary.lhs.span, "Expression must be a pointer-type",
                    `Got type '{expr_type.str()}'`
                )
            }
            let index_type = .check_expression(node.u.binary.rhs)
            if index_type.base != BaseType::I32 {
                error_span_note(
                    node.u.binary.rhs.span, "Index must be an integer",
                    `Got type '{index_type.str()}'`
                )
            }
            etype = expr_type.ptr
        }
        PlusEquals | MinusEquals | DivideEquals | MultiplyEquals => {
            // TODO: Only allow assignments to l-values, reject literals
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if not lhs.is_numeric() or not rhs.is_numeric() {
                error_span_note(
                    node.span, "Operator requires numeric types",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            if not lhs.eq(rhs) {
                error_span_note(
                    node.span, "Operands must be of the same type",
                    `Got types '{lhs.str()}' and '{rhs.str()}'`
                )
            }
            etype = lhs
        }
        Assignment => {
            // TODO: Only allow assignments to l-values, reject literals;
            let lhs = .check_expression(node.u.binary.lhs)
            let rhs = .check_expression(node.u.binary.rhs)
            if not lhs.eq(rhs) {
                error_span_note(
                    node.span, "Variable type does not match assignment type",
                    `Expected type '{lhs.str()}', got '{rhs.str()}'`
                )
            }
            etype = lhs
        }
        ScopeLookup => {
            if node.u.member.lhs.type != ASTType::Identifier {
                error_span(node.u.member.lhs.span, "Left hand side of `::` must be a struct name")
            }
            let struct_name = node.u.member.lhs.u.ident.name
            let struc = .structures.get(struct_name) as &Structure
            if not struc? {
                error_span(node.u.member.lhs.span, "Unknown struct with this name")
            }

            let field_name = node.u.member.name
            let var = .get_struct_member(struct_name, field_name)

            let s_methods = .methods.get(struct_name) as &Map
            let method = s_methods.get(field_name) as &Function
            if struc.is_enum and var? {
                // FIXME: This is a hack, we're modifying the AST Node type
                // This is an enum value
                node.type                = ASTType::EnumValue;
                node.u.enum_val.struct_def = struc;
                node.u.enum_val.name     = field_name;
                etype = struc.type
            } else if method? {
                etype = method.type
            } else {
                error_span(node.span, "Struct has no static method with this name")
            }
        }
        Member => {
            let lhs_type = .check_expression(node.u.member.lhs)
            if not lhs_type.is_struct_or_ptr() and not lhs_type.is_string() {
                error_span_note(
                    node.u.member.lhs.span, "LHS of member access must be a struct / string",
                    `Got type '{lhs_type.str()}'`
                )
            }
            node.u.member.is_pointer = (lhs_type.name == null)
            let struct_type = if lhs_type.name? then lhs_type else lhs_type.ptr

            let struct_name = struct_type.name
            let field_name = node.u.member.name

            let struc = .structures.get(struct_name) as &Structure
            let field = .get_struct_member(struct_name, field_name)

            let s_methods = .methods.get(struct_name) as &Map
            let method = s_methods.get(field_name) as &Function

            if struc? and field? and not struc.is_enum {
                etype = field.type;
            } else if method? {
                if method.is_static {
                    error_span_note_span(
                        node.span, "Member access requires a non-static method",
                        method.span, "This is a static method"
                    )
                }
                etype = method.type
            } else {
                error_span_note(
                    node.span, "Type has no member with this name",
                    `LHS type is '{struct_type.str()}'`
                )
            }
        }
        Cast => {
            let lhs_type = .check_expression(node.u.cast.lhs)
            if not .type_is_valid(node.u.cast.to) {
                error_span(node.u.cast.to.span, "Type does not exist");
            }
            etype = node.u.cast.to
        }
        IsNotNull => {
            let lhs_type = .check_expression(node.u.unary)
            if lhs_type.base != BaseType::Pointer {
                error_span_note(
                    node.span, "Can only use ? on pointer types",
                    `Type of expression is '{lhs_type.str()}'`
                )
            }
            etype = Type::new(BaseType::Bool, node.span)
        }
        Match => {
            .check_match(node, true)
            etype = node.etype
        }
        If => {
            .check_if(node, true)
            etype = node.etype
        }
        else => {
            println("Unhandled type in check_expression: %s", node.type.str())
            exit(1)
        }
    }
    node.etype = etype
    return etype
}


def TypeChecker::check_expression_statement(&this, node: &AST, body: &AST, is_expr: bool) {
    match body.type {
        // If this is an expression-statement, a non-block should also be an expression
        ASTType::Match => .check_match(body, is_expr)
        ASTType::If => .check_if(body, is_expr)

        ASTType::Block => .check_block(body, is_expr)
        else => .check_statement(body)
    }

    if is_expr {
        let ret = body.etype

        // For now, we'll allow expression statements to early-return from the function.
        // Maybe this should be disallowed?
        if body.returns {
            // Do nothing
        } else if not ret? {
            error_span(body.span, "Must yield a value in this branch")
        } else if not node.etype? {
            node.etype = ret
        } else if not node.etype.eq(ret) {
            error_span_note(
                body.span, "Yield type doesn't match previous branches",
                `Expected type '{node.etype.str()}', got '{ret.str()}'`
            )
        }
    }
    node.returns = node.returns and body.returns
}

def TypeChecker::check_match_for_enum(&this, struc: &Structure, node: &AST, is_expr: bool) {
    let mapping = Map::new()
    defer mapping.free()

    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        let cond = _case.cond
        let name: string
        if cond.type == ASTType::Identifier {
            name = cond.u.ident.name
            if not struc.find_field(name)? {
                error_span(cond.span, "Enum has no field with this name")
            }

            // FIXME: This is a hack, we're modifying the AST Node type
            cond.type = ASTType::EnumValue;
            cond.u.enum_val.struct_def = struc;
            cond.u.enum_val.name = name;
            cond.etype = struc.type

        } else {
            let cond_type = .check_expression(cond)
            if not cond_type.eq(struc.type) {
                error_span_note_span(
                    cond.span, "Condition does not match expression type",
                    node.u.match_stmt.expr.span, `Match expression is of type '{struc.type.str()}'`
                )
            }
            name = cond.u.enum_val.name
        }

        let prev = mapping.get(name) as &MatchCase
        if prev? {
            error_span_note_span(
                cond.span, "Duplicate condition name in match",
                prev.cond.span, "This condition was previously used here"
            )
        }
        mapping.insert(name, _case)
        if _case.body? {
            .check_expression_statement(node, _case.body, is_expr)
        }
    }

    let defolt = node.u.match_stmt.defolt
    if mapping.num_items != struc.fields.size {
        if not defolt? {
            error_span_note(
                node.span, "Match does not cover all cases",
                `Only {mapping.num_items} of {struc.fields.size} cases are covered`
            )
        }
        .check_expression_statement(node, defolt, is_expr)
    } else {
        if defolt? {
            error_span(node.u.match_stmt.defolt_span, "`else` case is not needed for this match")
        }
    }

    if is_expr and not node.etype? and not node.returns {
        error_span(node.span, "Expression-match must yield a value")
    }
}


def TypeChecker::check_match(&this, node: &AST, is_expr: bool) {
    let expr = node.u.match_stmt.expr
    let expr_type = .check_expression(expr)

    let struc: &Structure
    if expr_type.base == BaseType::Structure {
        struc = .structures.get(expr_type.name) as &Structure
        if struc.is_enum {
            .check_match_for_enum(struc, node, is_expr)
            return
        }
    }
    if expr_type.base != BaseType::I32 and
        expr_type.base != BaseType::Char and
        not expr_type.is_string() {
        error_span_note(
            expr.span, "This type cannot be matched on",
            `Expression type is '{expr_type.str()}'`
        )
    }
    // Here we have either i32 or char
    let cases = node.u.match_stmt.cases
    node.returns = (cases.size > 0)

    for let i = 0; i < cases.size; i += 1 {
        let _case = cases.at(i) as &MatchCase
        let cond_type = .check_expression(_case.cond)
        if not cond_type.eq(expr_type) {
            error_span_note_span(
                cond_type.span, "Condition does not match expression type",
                node.u.match_stmt.expr.span, `Match expression is of type '{struc.type.str()}'`
            )
        }
        if _case.cond.type != ASTType::IntLiteral and
            _case.cond.type != ASTType::CharLiteral and
            _case.cond.type != ASTType::StringLiteral {
            error_span(_case.cond.span, "Match condition must use only literals")
        }
        if _case.body? {
            .check_expression_statement(node, _case.body, is_expr)
        }
    }

    let defolt = node.u.match_stmt.defolt

    if not defolt? {
        error_span(node.span, "`else` case is missing")
    }
    .check_expression_statement(node, defolt, is_expr)

    if is_expr and not node.etype? and not node.returns {
        error_span(node.span, "Expression-match must yield a value")
    }
}

def TypeChecker::check_if(&this, node: &AST, is_expr: bool) {
    let cond_type = .check_expression(node.u.if_stmt.cond)
    if cond_type.base != BaseType::Bool {
        error_span_note(
            node.u.if_stmt.cond.span, "Condition must be a boolean",
            `Got type '{cond_type.str()}'`
        )
    }
    .check_expression_statement(node, node.u.if_stmt.body, is_expr)
    if node.u.if_stmt.els? {
        let else_stmt = node.u.if_stmt.els
        .check_expression_statement(node, else_stmt, is_expr)

        if node.u.if_stmt.body.returns and else_stmt.returns {
            node.returns = true
        }
    } else if is_expr {
        error_span(node.span, "Expression-if must have an 'else' branch")
    }
    if is_expr and not node.etype? and not node.returns {
        error_span(node.span, "Expression-if must yield a value")
    }
}

def TypeChecker::check_statement(&this, node: &AST) {
    match node.type {
        ASTType::Block => .check_block(node, false)
        ASTType::Defer => .check_expression(node.u.unary)
        ASTType::Match => .check_match(node, false)
        ASTType::Yield => {
            if not .can_yield {
                error_span(node.span, "Cannot yield in this context")
            }
            node.etype = .check_expression(node.u.unary)
        }
        ASTType::Return => {
            if not .cur_func? {
                error_span(node.span, "Return statement outside of function")
            }
            if not node.u.unary? {
                if .cur_func.return_type.base != BaseType::Void {
                    error_span_note_span(
                        node.span, "Cannot have empty return in non-void function",
                        .cur_func.return_type.span, `This function returns '{.cur_func.return_type.str()}'`
                    )
                }
            } else {
                let ret_type = .check_expression(node.u.unary)
                if .cur_func.return_type.base == BaseType::Void {
                    error_span_note_span(
                        node.u.unary.span, `Cannot return '{ret_type.str()}' in void function`,
                        .cur_func.span, "This function does not return a value"
                    )
                }
                if not ret_type.eq(.cur_func.return_type) {
                    error_span_note_span(
                        node.u.unary.span, `Return type '{ret_type.str()}' is incorrect`,
                        .cur_func.return_type.span, `This function returns '{.cur_func.return_type.str()}'`
                    )
                }
            }
            node.returns = true
        }
        ASTType::Break  | ASTType::Continue => {
            if not .in_loop {
                error_span(node.span, `{node.type.str()} statement outside of loop`)
            }
        }
        ASTType::VarDeclaration => {
            let var_decl = &node.u.var_decl
            if var_decl.init? {
                let init_type = .check_expression(var_decl.init)
                if init_type.base == BaseType::Method {
                    error_span(var_decl.init.span, "Cannot assign methods to variables")
                }
                if not var_decl.var.type? {
                    var_decl.var.type = init_type
                } else if not var_decl.var.type.eq(init_type) {
                    error_span_note(
                        var_decl.init.span, "Variable type does not match initializer type",
                        `Expected '{var_decl.var.type.str()}' but got '{init_type.str()}'`
                    )
                }
            } else {
                if not var_decl.var.type? {
                    error_span(var_decl.var.span, "Variable type cannot be inferred, specify explicitly");
                }
                if not .type_is_valid(var_decl.var.type) {
                    error_span(var_decl.var.type.span, "Invalid variable type");
                }
            }
            .push_var(var_decl.var)
        }
        ASTType::While => {
            let was_in_loop = .in_loop
            .in_loop = true
            let cond_type = .check_expression(node.u.loop.cond)
            if cond_type.base != BaseType::Bool {
                error_span_note(
                    node.u.loop.cond.span, "Condition must be boolean",
                    `Got type '{cond_type.str()}'`
                )
            }
            .check_statement(node.u.loop.body)
            .in_loop = was_in_loop
        }
        ASTType::For => {
            let was_in_loop = .in_loop
            .in_loop = true
            .push_scope()
            if node.u.loop.init? {
                .check_statement(node.u.loop.init)
            }
            if node.u.loop.init? {
                let cond_type = .check_expression(node.u.loop.cond)
                if cond_type.base != BaseType::Bool {
                    error_span_note(
                        node.u.loop.cond.span, "Condition must be boolean",
                        `Got type '{cond_type.str()}'`
                    )
                }
            }
            if node.u.loop.incr? {
                .check_statement(node.u.loop.incr)
            }
            .check_statement(node.u.loop.body)
            .pop_scope()
            .in_loop = was_in_loop
        }
        ASTType::If => .check_if(node, false)
        else => .check_expression(node)
    }
}

def TypeChecker::check_block(&this, node: &AST, can_yield: bool) {
    let could_yield = .can_yield
    .can_yield = can_yield

    let yield_span: Span

    .push_scope();
    let statements = node.u.block.statements;
    for let i = 0; i < statements.size; i += 1 {
        let statement = statements.at(i) as &AST
        .check_statement(statement);
        if statement.returns {
            node.returns = true
        }
        if statement.type == ASTType::Yield {
            if node.etype? {
                error_span_note_span(
                    statement.span, "Cannot yield multiple times in a block",
                    yield_span, "Previously yield here is here"
                )
            }
            node.etype = statement.etype
            yield_span = statement.span
        }
    }

    .pop_scope();
    .can_yield = could_yield
}

def TypeChecker::check_function(&this, func: &Function) {
    let prev_func = .cur_func
    .cur_func = func
    .push_scope();

    // The types of parameters and return are checked in decl-pass
    for let i = 0; i < func.params.size; i += 1 {
        let var = func.params.at(i) as &Variable
        .push_var(var)
    }

    if func.body? {
        .check_block(func.body, false)
        if not func.body.returns and func.return_type.base != BaseType::Void {
            if not func.name.eq("main") {
              error_span(func.span, "Function does not always return")
            }
        }
    }

    .pop_scope()
    .cur_func = prev_func
}

def TypeChecker::check_all_functions(&this, program: &Program) {
    for let i = 0; i < program.functions.size; i += 1 {
        let func = program.functions.at(i) as &Function
        let name        = func.name;
        let struct_name = func.method_struct_name
        let func_type = null as &Type

        if func.is_method {
            let s_methods = .methods.get(struct_name) as &Map
            if not s_methods? {
                error_span(func.span, "Type for method does not exist")
            }
            if s_methods.exists(name) {
                let method = s_methods.get(name) as &Function
                error_span_note_span(
                    func.span, "Method is already defined for this type",
                    method.span, "Previous definition here"
                )
            }
            let var = .get_struct_member(struct_name, name)
            if var? {
                error_span_note_span(
                    func.span, "Type already has a field with this name",
                    var.span, "Previous definition here"
                )
            }

            func_type = Type::new(BaseType::Method, func.span)
            func_type.name = struct_name
        } else {
            func_type = Type::new(BaseType::Function, func.span)

            if .functions.exists(name) {
                let prev = .functions.get(name) as &Function
                error_span_note_span(
                    func.span, "Function is already defined",
                    prev.span, "Previous definition here"
                )
            }
        }
        func_type.func_def = func;

        func_type.params = Vector::new()
        for let j = 0; j < func.params.size; j += 1 {
            let param = func.params.at(j) as &Variable
            if not .type_is_valid(param.type) {
                error_span(param.type.span, "Invalid parameter type")
            }
            func_type.params.push(param.type);
        }
        if not .type_is_valid(func.return_type) {
            error_span(func.return_type.span, "Invalid return type")
        }
        func_type.return_type = func.return_type;
        func.type             = func_type;

        if func.is_method {
            let s_methods = .methods.get(struct_name) as &Map
            s_methods.insert(name, func)
        } else {
            .functions.insert(name, func)
        }
    }

    for let i = 0; i < program.functions.size; i += 1 {
        .check_function(program.functions.at(i) as &Function)
    }
}

def TypeChecker::dfs_structs(&this, struc: &Structure, results: &Vector, done: &Map) {
    done.insert(struc.name, struc)

    for let i = 0; i < struc.fields.size; i += 1 {
        let field = struc.fields.at(i) as &Variable
        if not .type_is_valid(field.type) {
            error_span(field.type.span, "Type of field is undefined");
        }

        // Don't need to ensure dependency order for externs
        if not struc.is_extern and field.type.base == BaseType::Structure {
            let neib_name = field.type.name
            let neib_struc = .structures.get(neib_name) as &Structure
            if not done.exists(neib_name) {
                .dfs_structs(neib_struc, results, done)
            }
        }
    }
    results.push(struc)
}

def TypeChecker::check_all_structs(&this, program: &Program) {
    for let i = 0; i < program.structures.size; i += 1 {
        let struc = program.structures.at(i) as &Structure
        let name = struc.name

        if .structures.exists(name) {
            let prev = .structures.get(name) as &Structure
            error_span_note_span(
                struc.span, "Struct has already been defined",
                prev.span, "Previous definition here"
            )
        }

        .structures.insert(name, struc)
        .methods.insert(name, Map::new())
    }

    // TODO: Check for loops in the dependency graph, and error
    let done = Map::new()        // Essentially hashset
    let results = Vector::new()  // Order for topological sort
    for let i = 0; i < program.structures.size; i += 1 {
        let struc = program.structures.at(i) as &Structure
        if not done.exists(struc.name) {
            .dfs_structs(struc, results, done)
        }
    }

    done.free()
    program.structures.free()
    program.structures = results
}

def TypeChecker::check_program(&this, program: &Program) {
    .check_all_structs(program);

    .push_scope();
    for let i = 0; i < program.global_vars.size; i += 1 {
        let var = program.global_vars.at(i) as &AST
        .check_statement(var)
    }

    .check_all_functions(program);
    .pop_scope();
}
